#!/usr/bin/perl

use strict;
use lib "$ENV{GUS_HOME}/lib/perl";
use Getopt::Long;
use GUS::Supported::GusConfig;

$| = 1;

my ($gusConfigFile, $dropApiDB, $dropGUS, $create, $db, $allowFailures, $verbose);

&GetOptions("gusConfigFile=s" => \$gusConfigFile,
           "dropApiDB!" => \$dropApiDB,
           "dropGUS!" => \$dropGUS,
           "allowFailures!" => \$allowFailures,
           "create!" => \$create,
           "verbose!" => \$verbose,
           "db=s" => \$db);

my $x = $dropApiDB + $dropGUS + $create;
if (!$db || ($x != 1)) {
  die "

Install the ApiDB and ApiDBTuning schemas and the ApidDB patches to GUS.  Or, uinstall them (or uninstall the GUS schemas)

usage: installApidbSchema --db database [--create | --dropApiDB | --dropGUS] [--gusConfigFile gus_config_file] [--allowFailures] [--verbose]

Caution: only use --allowFailures if you know what you are doing

create - creates the ApiDB and ApiDBTuning schemas and patches GUS.

dropApiDB - drops the ApiDB and ApiDBTuning schemas, and ApiDB patches to GUS.

dropGUS - drops the Core, DoTS, PROT, RAD, SRes, STUDY, TESS (and all VER) schemas

Log is printed to STDOUT

Verbose prints commands run to STDERR

";
}

my $d = 'GUS schema';
$d = 'ApiDB and ApiDBTuning schemas' if $dropApiDB;

if ($dropApiDB || $dropGUS) {
    print "\nYou are about to UNINSTALL the $d on:\n  $db\nType the name of the instance to confirm: ";
    my $confirm = <STDIN>;
    chomp $confirm;
    die "You did not correctly confirm the db instance\n" unless $db eq $confirm;
}

my $gusconfig = GUS::Supported::GusConfig->new($gusConfigFile);

my $login = $gusconfig->getDatabaseLogin();
my $password = $gusconfig->getDatabasePassword();


# PLEASE READ BEFORE ADDING TO @create
#
# The list is ordered according to these rules:
# first:  changes to GUS
# second: create ApidbTuning schema
# third:  create Apidb schema
# fourth: create tables within Apidb, in dependency order as needed
#
# This ordering helps ensure that when/if we drop, the dropping proceeds
# in the correct order, avoiding bogus failures from dropping what was
# not yet created.
#
# ALSO: if you are adding a create script for the Apidb schema
#       it is good practice to write a parallel drop script
#       so that if needed, the create can be manually reversed

my @create = qw(
               insertGusVersion.sql
               removeNullConstraintsFromSimilarityTables.sql
               createGusTuning.sql
               modifySeqVariation.sql

               createApidbTuningSchema.sql

               createApidbSchema.sql
	       createAnalysisMethodInvocation.sql
	       createChromosome6Orthology.sql
	       createDataSource.sql
	       createDbLinks.sql
	       createDbUser.sql
	       createExpressionProfileTables.sql
	       createGeneInteractionTables.sql
	       createGeneMappingView.sql
	       createGeneFeatureProduct.sql
	       createGeneFeatureName.sql
	       createIsolateVocabulary.sql
	       createMassSpecSummary.sql
	       createOrthologGroup.sql
	       createOrthomclEngine.sql
	       createPhylogeneticProfile.sql
	       createPhylogeneticTree.sql
	       createRelatedNaFeature.sql
	       createReportCache.sql
	       createRodentChrColors.sql
	       createSequenceAttributeTables.sql
	       createStoredProcedures.sql
	       createSyntenyTables.sql
	       createToxodbGenesView.sql
	       createTransmembraneTable.sql
	       createSpliceSiteFeature.sql
	       createTuningManager.sql
	       createContinents.sql
	       createWorkflow.sql
	       createsiRNA.sql
	       createNextGenSeqCoverage.sql
	       createNextGenSeq_Align.sql
	       createPlasmoPfalLocations.sql
	       createPlasmoMapp.sql
	       createGeneGenomicSequence_Split.sql
	       createOrganism.sql
	       createIsolateMapping.sql
	       createRUMIntronFeature.sql
	       createGeneLodScoresTable.sql
               createBlatProteinAlignment.sql
	       createPhenotypeFeature.sql
	       createGFF3Table.sql	
	     );

# drop GUS first, then ApidbTuning, then Apidb (same order as we created).
# for GUS, we only drop the tuning indexes, as the other GUS changes don't
# need to be reversed.  The trick here is to order these to avoid failures
my @delete = qw( deleteGusVersion.sql
                 restoreNullConstraintsFromSimilarityTables.sql
                 dropGusTuning.sql
      	         dropDbLinks.sql
	         dropDbUser.sql
                 dropApidbTuningSchema.sql
                 dropApidbSchema.sql
               );

if ($create) {
  for my $sql (@create) {
    &runSql($login, $password, $db, $sql);
  }

} elsif ($dropApiDB) {

  for my $sql (@delete) {
    &runSql($login, $password, $db, $sql);
  }

} elsif ($dropGUS) {
    &runSql($login, $password, $db, 'dropEntireGusSchema.sql');

}

print STDERR "\nDone.\n";

sub runSql {
  my ($login, $password, $db, $file) = @_;

  my $fullFile = "$ENV{GUS_HOME}/lib/sql/apidbschema/$file";

  -e $fullFile || die "File .sql file '$fullFile' does not exist\n";

  my $tmpFile = "/tmp/$file.$$";  # append the process id
  unlink($tmpFile);  # in case of a old one
  my $cmd;
  if (!$allowFailures) {
      $cmd = "echo 'whenever sqlerror exit sql.sqlcode;' > $tmpFile";
      runCmd($cmd, $tmpFile);
  }
  $cmd = "echo 'set echo on;' >> $tmpFile";
  runCmd($cmd, $tmpFile);

  $cmd = "cat $fullFile >> $tmpFile";
  runCmd($cmd, $tmpFile);
  $cmd = "sqlplus $login\@$db/$password \@$tmpFile";
  print STDOUT "\n==============================================================\n";
  print STDOUT "Running $tmpFile\n";
  print STDOUT "==============================================================\n";

  runCmd($cmd, $tmpFile);
  unlink($tmpFile);
}

sub runCmd {
    my ($cmd, $tmpFile) = @_;
    print STDERR "\nrunning command: $cmd\n" if $verbose;
    system($cmd);
    my $status = $? >> 8;
    if ($status) {
      unlink($tmpFile);
      die "Failed with status '$status running cmd: \n$cmd'\n";
    }
}
